namespace olm {
    void set_logger(Logger logger);
};

callback interface Logger {
    void log(string log_line);
};

callback interface ProgressListener {
    void on_progress(i32 progress, i32 total);
};

[Error]
enum MachineCreationError {
    "Identifier",
    "CryptoStore",
};

[Error]
enum KeyImportError {
    "Export",
    "CryptoStore",
};

[Error]
enum CryptoStoreError {
    "CryptoStore",
    "OlmError",
    "Serialization",
    "Identifier",
};

[Error]
enum DecryptionError {
    "Identifier",
    "Serialization",
    "Megolm",
};

dictionary DeviceLists {
    sequence<string> changed;
    sequence<string> left;
};

dictionary KeysImportResult {
    i32 total;
    i32 imported;
};

dictionary DecryptedEvent {
    string clear_event;
    string sender_curve25519_key;
    string? claimed_ed25519_key;
    sequence<string> forwarding_curve25519_chain;
};

dictionary Device {
    string user_id;
    string device_id;
    record<DOMString, string> keys;
    sequence<string> algorithms;
    string? display_name;
    boolean is_blocked;
};

dictionary StartSasResult {
    Sas sas;
    OutgoingVerificationRequest request;
};

dictionary Sas {
    string other_user_id;
    string other_device_id;
    string flow_id;
    boolean is_done;
    boolean is_cancelled;
    boolean can_be_presented;
    boolean timed_out;
    boolean supports_emoji;
};

dictionary VerificationRequest {
    string other_user_id;
    string? other_device_id;
    string flow_id;
    boolean is_cancelled;
    boolean is_done;
    boolean is_ready;
    boolean we_started;
    boolean is_passive;
    string? room_id;
    CancelCode? cancel_code;
    sequence<string>? their_methods;
    sequence<string>? our_methods;

};

enum CancelCode {
    "User",
    "Timeout",
    "UnknownTransaction",
    "UnknownMethod",
    "UnexpectedMessage",
    "KeyMismatch",
    "UserMismatch",
    "InvalidMessage",
    "Accepted",
};

dictionary KeyRequestPair {
    Request? cancellation;
    Request key_request;
};

[Enum]
interface OutgoingVerificationRequest {
    ToDevice(string request_id, string event_type, string body);
    InRoom(string request_id, string room_id, string event_type, string content);
};

[Enum]
interface Request {
    ToDevice(string request_id, string event_type, string body);
    KeysUpload(string request_id, string body);
    KeysQuery(string request_id, sequence<string> users);
    KeysClaim(string request_id, record<DOMString, record<DOMString, string>> one_time_keys);
};

enum RequestType {
    "KeysQuery",
    "KeysClaim",
    "KeysUpload",
    "ToDevice",
};

interface OlmMachine {
    [Throws=MachineCreationError]
    constructor([ByRef] string user_id, [ByRef] string device_id, [ByRef] string path);

    record<DOMString, string> identity_keys();
    string user_id();
    string device_id();

    [Throws=CryptoStoreError]
    string receive_sync_changes([ByRef] string events,
                              DeviceLists device_changes,
                              record<DOMString, i32> key_counts);
    [Throws=CryptoStoreError]
    sequence<Request> outgoing_requests();
    [Throws=CryptoStoreError]
    void mark_request_as_sent(
        [ByRef] string request_id,
        RequestType request_type,
        [ByRef] string response
    );

    [Throws=DecryptionError]
    DecryptedEvent decrypt_room_event([ByRef] string event, [ByRef] string room_id);
    [Throws=CryptoStoreError]
    string encrypt([ByRef] string room_id, [ByRef] string event_type, [ByRef] string content);

    [Throws=CryptoStoreError]
    Device? get_device([ByRef] string user_id, [ByRef] string device_id);
    [Throws=CryptoStoreError]
    sequence<Device> get_user_devices([ByRef] string user_id);

    void update_tracked_users(sequence<string> users);
    [Throws=CryptoStoreError]
    Request? get_missing_sessions(sequence<string> users);
    [Throws=CryptoStoreError]
    sequence<Request> share_room_key([ByRef] string room_id, sequence<string> users);

    sequence<VerificationRequest> get_verification_requests([ByRef] string user_id);
    VerificationRequest? get_verification_request([ByRef] string user_id, [ByRef] string flow_id);
    Sas? get_verification([ByRef] string user_id, [ByRef] string flow_id);

    OutgoingVerificationRequest? accept_verification_request(
        [ByRef] string user_id,
        [ByRef] string flow_id,
        sequence<string> methods
    );

    [Throws=CryptoStoreError]
    StartSasResult? start_sas_verification([ByRef] string user_id, [ByRef] string flow_id);
    [Throws=CryptoStoreError]
    OutgoingVerificationRequest? confirm_verification([ByRef] string user_id, [ByRef] string flow_id);
    OutgoingVerificationRequest? cancel_verification([ByRef] string user_id, [ByRef] string flow_id);
    OutgoingVerificationRequest? accept_sas_verification([ByRef] string user_id, [ByRef] string flow_id);

    sequence<i32>? get_emoji_index([ByRef] string user_id, [ByRef] string flow_id);
    sequence<i32>? get_decimals([ByRef] string user_id, [ByRef] string flow_id);

    [Throws=DecryptionError]
    KeyRequestPair request_room_key([ByRef] string event, [ByRef] string room_id);

    [Throws=CryptoStoreError]
    string export_keys([ByRef] string passphrase, i32 rounds);
    [Throws=KeyImportError]
    KeysImportResult import_keys(
        [ByRef] string keys,
        [ByRef] string passphrase,
        ProgressListener progress_listener
    );
    [Throws=CryptoStoreError]
    void discard_room_key([ByRef] string room_id);
};
